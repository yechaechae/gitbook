
픽업 위치, 타임스탬프 데이터만 사용

여행시간 예측은 회귀
y는 여행시간을 나타내고 x는 features(독립변수)
엡실론은 에러 f는 y와 x의 관계를 나타내는 알수없는 회귀

SVM, k-nearest neighbors, nn, deep learning으로 예측한 논문 존재
저자는 트리에 집중, 특히 Random forest, Extra Trees를 포함하는 CART 와 bagged or boosted 앙상블, 
최근 Xgboost와 LightGBM알고리즘으로 제안된 random forest, extra trees
이 과정은 train하기 쉽고 딥러닝에 비하면 적은 부담을 준다.

CART regression tree

ensemble fo B = 3 



Learning to Estimate the Travel Time

여행시간을 예측하는 시스템은 이미 많이 알려져 있다. 
존재하는 솔루션은 두가지 카테고리로 나뉘어진다.
1. route-base solution, 직관적인 물리적인 모델로 : 주어진 경로의 전체 여행 시간은 각 도로를 통과하는 이동 시간의 합계로 공식화 segment1 그리고 각 교차로에서의 지연 시간.
2. data-driven solution, machine learning

저자는 존재하는 메소드의 drawback문제를 극복하는 머신러닝모델 제안
위치 기반의 효과적인 데이터 , floating-car data, road network data, uservehavior information -> 과거데이터기반, 실시간
wide linear model, depp neural network, recurrent neural network의 이점들을 혼합

feature를 몇가지 타입으로 요약
Spatial Information: 여행시간은 지리적인 위치와 경로와 높은 연관성이 있다. 지리데이터
Temporal Information : 여행 출발시간도 여행시간 예측에 영향을 준다. 시간 
Traffic Information : 실시간 교통정보 
Personalized Information : 운전자 개인 정보
Augmented Information : 그 외에 사용할 수 있는 모든 정보 ex. 날씨, 교통 법규 등 

GBDT, FM은 ETA learning 문제를 해결하는데 가장 좋은 알고리즘은 아니다.
GBDT는 큰 feature 셋에 적용하기 어렵다. FM 성능은 feature에 의존적이고 모델 표현에 제한적이다.

Wide & Deep Learning
모델은 두 블락 구조를 가진다. wide, Deep

wide 모델은 logistic regression과 같이 기존의 추첮ㄴ 알고리즘과 같은 generalized linear model이라고 설명될 수 있다.
deep model과 비교하면 wide 모델은 shallow(얕은) 모델이라고 여겨진다.

deep 모델은 sparse input feature를 dense feature로 변환한다. feature embedding layer를 사용해서 
dense input feature는 임베디드 된 피쳐와 feed를 multiple layer perceptron(MLP)로 알려진 feed-forward neural network(FNN)로 이어준다? 

가장 위의 계층인 regressor는 마지막 예측을 제공하기 위해서 wide와 deep 모델에서 나온 아웃풋을 합친다.
보통 sparse feature는 categorical 정보를 나타내고 dense feature는 numerical 정보를 나타낸다. ex) driver-id는 sparse feature이고 반면에 경로 길이는 dense feature이다.

LSTM은 recurrent neural network(RNN)이다. sequential 데이터로 훈련할 때 성공적이었다. 
LSTM은 각각의 로컬 정보(세그먼트 및 시퀀스에 따른 장기 종속성)를 모두 캡처 할 수 있습니다.
**road segment sequence 문제를 모델링 하기 위해서 사용**

LSTM은 RNN의 gradient vanishing 과 exploding문제를 감소시킨다.  추가적인 메모리 셀을 이용해서 











